{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fnil\fcharset134 PingFangSC-Regular;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red255\green238\blue149;\red21\green102\blue47;}
{\*\expandedcolortbl;;\cssrgb\c100000\c94118\c64706;\cssrgb\c7451\c46667\c23922\c57630;}
\paperw11900\paperh16840\margl1440\margr1440\vieww21600\viewh14980\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs48 \cf0 \
\'ba\'f3\'cc\'a8\'d7\'d3\'bd\'f8\'b3\'cc\'cb\'c0\'b5\'c4\'cc\'ab\'bf\'ec\'a3\'ac\'c0\'b4\'b2\'bb\'bc\'b0fg\'a3\'afbg\'be\'cddelete\'c1\'cb\'a1\'a3\
\
\'b9\'fe\'b9\'fe\'a3\'ac\'d0\'b4\'cd\'ea\'c1\'cb\'a1\'a3\'d5\'e2\'b4\'ce\'ca\'b5\'d1\'e9\'ca\'c7\'d7\'d4\'bc\'ba\'b6\'c0\'c1\'a2\'cd\'ea\'b3\'c9\'b5\'c4\'a3\'ba\
  1. Eval \'ba\'af\'ca\'fd\'c4\'d8\'ca\'c7\'b5\'f7\'d3\'c3\'bd\'e2\'ce\'f6\'ba\'af\'ca\'fd\'ba\'cd\'c4\'da\'d6\'c3\'a3\'af\'bf\'c9\'d6\'b4\'d0\'d0\'ce\'c4\'bc\'fe\'b5\'c4\
  2.waitfg\'c4\'d8\'ca\'c7\'d2\'aa\'d3\'c3busy loop\'b6\'f8\'b2\'bb\'ca\'c7waitpid\'ba\'af\'ca\'fd\'b5\'c4\
  3.\'b4\'a6\'c0\'ed\'ba\'f3\'cc\'a8\'bd\'f8\'b3\'ccsigchld\'b5\'c4\'d0\'c5\'ba\'c5\'b5\'c4handler\'b2\'bb\'d2\'aa\'d7\'e8\'c8\'fb\'a1\'a3\
\
\'c6\'e4\'ca\'b5\'a3\'ac\'ce\'d2\'be\'f5\'b5\'c3\'ba\'dc\'b6\'e0\'b9\'a4\'d7\'f7\'d2\'d1\'be\'ad\'b8\'f8\'c4\'e3\'cc\'e1\'b9\'a9\'c1\'cb\'a3\'ac\'ce\'d2\'c3\'c7\'d0\'e8\'d2\'aa\'d0\'b4\'b5\'c4\'b2\'a2\'b2\'bb\'b6\'e0\'a3\'ac\'b6\'f8\'c7\'d2\'d0\'c5\'ba\'c5\'bf\'d8\'d6\'c6\'d6\'bb\'d2\'aa\'cc\'ed\'bc\'d3\'d2\'bb\'d0\'a9\'b6\'af\'d7\'f7\'c4\'d8\'be\'cd\'bf\'c9\'d2\'d4\'c1\'cb\'a1\'a3\
\
//eval \'be\'cd\'ca\'c7\'b5\'f7\'d3\'c3\'bd\'e2\'ce\'f6\'ba\'af\'ca\'fd\'c8\'b7\'b6\'a8\'b2\'ce\'ca\'fd\'a3\'ac\'c8\'bb\'ba\'f3\'b4\'ab\'b5\'dd\'b8\'f8execve\'ba\'af\'ca\'fd\'c8\'c3\'cb\'fb\'b5\'f7\'d3\'c3\'a1\'a3\'c8\'e7\'b9\'fb\'ca\'c7\
//\'c4\'da\'d6\'c3\'c0\'e0\'d0\'cd\'be\'cd\'c1\'a2\'c2\'ed\'b5\'f7\'d3\'c3\'a3\'ac\'c8\'e7\'b9\'fb\'ca\'c7\'bf\'c9\'d6\'b4\'d0\'d0\'ce\'c4\'bc\'fe\'be\'cd\'b4\'b4\'bd\'a8\'d7\'d3\'bd\'f8\'b3\'cc\'d6\'b4\'d0\'d0\'a1\'a3\
void eval(char *cmdline) \
\{\
    char *argv[MAXARGS];\
    char buf[MAXLINE];\
    int bg;\
    pid_t pid;\
    sigset_t mask;\
    strcpy(buf,cmdline);\
    //&\'ba\'f3\'cc\'a8\'d6\'b4\'d0\'d0\'b7\'b5\'bb\'d81\
    bg = parseline(buf,argv);\
    //\'bf\'d5\'d0\'d0\
    if(argv[0]==NULL)\
        return;\
    int builtin;\
    builtin = builtin_cmd(argv);\
    if(!builtin)\
    \{\
        //\'c7\'b0\'cc\'a8\'d6\'b4\'d0\'d0,\'bd\'ab\'c7\'b0\'cc\'a8\'d6\'b4\'d0\'d0\'b5\'c4\'b4\'b4\'bd\'a8\'d2\'bb\'b8\'f6\'bd\'f8\'b3\'cc\'d7\'e9\'a3\'ac\'d4\'da\'c7\'b0\'cc\'a8\'d4\'cb\'d0\'d0\'d6\'d0\'b4\'b4\'bd\'a8\'b5\'c4\'d7\'d3\'bd\'f8\'b3\'cc\'d2\'b2\'c8\'ab\'b2\'bf\'d4\'da\'d5\'e2\'b8\'f6\'bd\'f8\'b3\'cc\'d7\'e9\'d6\'d0\
        if(!bg)\
        \{\
            sigemptyset(&mask);\
            sigaddset(&mask,SIGCHLD);\
            sigprocmask(SIG_BLOCK,&mask,NULL);\
            if((pid=fork())==0)\
            \{\
                sigprocmask(SIG_UNBLOCK,&mask,NULL);\
                // \'d2\'d4\'b5\'b1\'c7\'b0\'bd\'f8\'b3\'cc\'b4\'b4\'bd\'a8\'bd\'f8\'b3\'cc\'d7\'e9\
                setpgid(0,0);\
                if(execve(argv[0],argv,environ)<0)\
                \{\
                printf("%s command not found\\n",argv[0] );\
                exit(0);\
                \}\
            \}\
            addjob(jobs,pid,FG,cmdline);\
            //\'d6\'f7\'bd\'f8\'b3\'cc\'bb\'e1\'d4\'da\'d5\'e2\'c0\'ef\'d7\'e8\'c8\'fb\'a3\'ac\'b2\'bb\'bb\'e1\'b5\'bd\'c6\'e4\'cb\'fb\'b5\'d8\'b7\'bd\
            sigprocmask(SIG_UNBLOCK,&mask,NULL);\
            waitfg(pid);\
        \}\
        //\'ba\'f3\'cc\'a8\'d6\'b4\'d0\'d0\'a3\'ac\'d3\'d0signal\'b4\'a6\'c0\'ed\
        if(bg)\
        \{\
            //addjob\'bb\'e1\'ba\'cd\'c7\'b0\'c3\'e6\'b5\'c4signal\'c0\'efdelete\'be\'ba\'d5\'f9\'a3\'ac\'cb\'f9\'d2\'d4\'cb\'f8\'b6\'a8.\
            sigemptyset(&mask);\
            sigaddset(&mask,SIGCHLD);\
            sigprocmask(SIG_BLOCK,&mask,NULL);\
            if((pid = fork())==0)\
            \{\
                //\'d7\'d3\'bd\'f8\'b3\'cc\'bc\'cc\'b3\'d0\'b8\'b8\'bd\'f8\'b3\'cc\'d7\'e8\'c8\'fb\'b5\'c4\'d0\'c5\'ba\'c5\'a3\'ac\'cb\'f9\'d2\'d4\'d2\'aa\'bd\'e2\'cb\'f8\'a1\'a3\
                sigprocmask(SIG_UNBLOCK,&mask,NULL);\
                if(execve(argv[0],argv,environ)<0)\
                \{\
                    printf("%s command not found\\n",argv[0] );\
                    exit(0);\
                \}\
            \}\
            addjob(jobs,pid,BG,cmdline);\
            printf("[%d] (%d) %s\\n", pid2jid(pid),pid,cmdline);\
            //\'b8\'b8\'bd\'f8\'b3\'cc\'bd\'e2\'cb\'f8\'a3\'ac\'d6\'bb\'d3\'d0\'bf\'c9\'d2\'d4\'b4\'a6\'c0\'edsigchld\'d0\'c5\'ba\'c5\
            sigprocmask(SIG_UNBLOCK,&mask,NULL);\
        \}\
    \}\
    return;\
\}\
\
int builtin_cmd(char **argv) \
\{\
    //\'c8\'e7\'b9\'fb\'cf\'e0\'b5\'c8\'b7\'b5\'bb\'d80,argv[0]\'ca\'c7\'b8\'f6\'d6\'b8\'d5\'eb\
    if(!strcmp(argv[0],"quit"))\
        exit(0);\
    if(!strcmp(argv[0],"bg"))\
    \{\
        do_bgfg(argv);\
        return 1;\
    \}\
    if(!strcmp(argv[0],"fg"))\
    \{\
        do_bgfg(argv);\
        return 1;\
    \}\
    //jobs list all background job,\
    if(!strcmp(argv[0],"jobs"))\
    \{\
        listjobs(jobs);\
        return 1;\
    \}\
    if(!strcmp(argv[0],"&"))\
        return 1;\
    return 0;     /* not a builtin command */\
\}\
\
/* \
 * do_bgfg - Execute the builtin bg and fg commands\
 */\
\
//bg job \'b0\'d1 stopped bg\'bb\'bb\'b3\'c9running bg\
//fg job \'b0\'d1stopped\'bb\'f2\'d5\'dfrunning bg\'bb\'bb\'b5\'bdfg\'c9\'cf\
 \
void do_bgfg(char **argv) \
\{\
    pid_t pid;\
    struct job_t *job;\
    //const char *s = argv[1];\
    if (argv==NULL)\
    \{\
        printf("no command arguments\\n");\
        return;\
    \}\
    //jid\
   if((argv[1][0]) == '%')\
    \{\
        //temp = jid\
        int jid = atoi(argv[1]+1);\
        job = getjobjid(jobs,jid);\
    \}\
    //pid\
    else\
    \{\
        int temp = atoi(argv[1]);\
        pid = temp;\
        job = getjobpid(jobs,pid);\
    \}\
    if(job==NULL)\
    \{\
        printf("%s: No such job\\n",argv[1] );\
        return;\
    \}\
    else\
    \{\
        if(!strcmp(argv[0],"bg"))\
        \{\
            printf("[%d], (%d)  %s\\n",job->jid,job->pid,job->cmdline);\
            //\'b7\'a2\'cb\'cdsigcont\
            job->state = BG;\
            kill(job->pid,SIGCONT);\
        \}\
        else \
        \{\
            job->state = FG;\
            kill(-(job->pid),SIGCONT);\
            //\'d4\'da\'d5\'e2\'c0\'ef\'b6\'c2\'c8\'fb\
            waitfg(job->pid);\
        \}\
    \}\
    return;\
\}\
\
/* \
 * waitfg - Block until process pid is no longer the foreground process\
 */\
//\'b8\'f9\'be\'ddhint\'ca\'b9\'d3\'c3busy loop\
void waitfg(pid_t pid)\
\{\
   while(pid == fgpid(jobs))\
   \{\
    sleep(0);\
   \}\
    return;\
\}\
\
/*****************\
 * Signal handlers\
 *****************/\
\
/* \
 * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever\
 *     a child job terminates (becomes a zombie), or stops because it\
 *     received a SIGSTOP or SIGTSTP signal. The handler reaps all\
 *     available zombie children, but doesn't wait for any other\
 *     currently running children to terminate.  \
 */\
void sigchld_handler(int sig) \
\{\
    pid_t pid;\
    //struct job_t *job;\
    //\'ba\'f3\'cc\'a8\'bd\'f8\'b3\'cc\'cb\'c0\'b5\'c4\'cc\'ab\'bf\'ec\'a3\'ac\'bb\'b9\'c3\'bb\'c0\'b4\'b5\'c3\'bc\'b0fg\'a3\'afbg\'be\'cddelete\'c1\'cb,\'b2\'bb\'c4\'dc\'d5\'e2\'d1\'f9\'a3\'ac\'d2\'aa\'b5\'c8\
    if((pid = waitpid(-1,NULL,WNOHANG|WUNTRACED))<0)\
    \{\
        unix_error("waitpid");\
        return;\
    \}\
    deletejob(jobs,pid);\
    return;\
   \
\}\
\
\
//\'ca\'a3\'cf\'c2\'b5\'c4\'d0\'c5\'ba\'c5\'be\'cd\'ca\'c7\'b6\'d4\'d3\'da\'c7\'b0\'cc\'a8\'b3\'cc\'d0\'f2\'b6\'f8\'d1\'d4\
/* \
 * sigint_handler - The kernel sends a SIGINT to the shell whenver the\
 *    user types ctrl-c at the keyboard.  Catch it and send it along\
 *    to the foreground job.  \
 */\
void sigint_handler(int sig) \
\{\
    pid_t pid;\
    pid = fgpid(jobs);\
    kill(-pid, SIGINT);\
    //struct job_t * jobint = getjobpid(jobs, pid);\
    //jobint->state = ST;\
    deletejob(jobs,pid);\
    return;\
\}\
\
/*\
 * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever\
 *     the user types ctrl-z at the keyboard. Catch it and suspend the\
 *     foreground job by sending it a SIGTSTP.  \
 */\
void sigtstp_handler(int sig) \
\{\
    pid_t pid;\
    pid = fgpid(jobs);\
    kill(-pid, SIGTSTP);\
    struct job_t * jobint = getjobpid(jobs, pid);\
    jobint->state = ST;\
    return;\
\}\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1 \cf2 \cb3 \CocoaLigature0 tsh> ./bogus\
./bogus command not found\
tsh> ./myspin 10\
tsh> ./myspin 3 &\
[1] (4099) ./myspin 3 &\
\
tsh> ./myspin 4 &\
[2] (4101) ./myspin 4 &\
\
tsh> jobs\
[1] (4099) Running ./myspin 3 &\
[2] (4101) Running ./myspin 4 &\
tsh> fg %1\
tsh> jobs\
[1] (4099) Stopped ./myspin 3 &\
[2] (4101) Running ./myspin 4 &\
tsh> bg %3\
%3: No such job\
tsh> bg %1\
[1], (4099)  ./myspin 3 &\
\
tsh> jobs\
[1] (4099) Running ./myspin 3 &\
[2] (4101) Running ./myspin 4 &\
tsh> fg %1\
tsh> quit\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \CocoaLigature1 \
\'d7\'ee\'ba\'f3\'b5\'c4\'b2\'e2\'ca\'d4\'bd\'e1\'b9\'fb\'a1\'a3\
\
}